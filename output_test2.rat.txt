Token: keyword   Lexeme: function
	<Rat19F> -> <Opt_Function_Definitions> %% <Opt_Declaration_List> <Statement_List> %%
	<Opt_Function_Definitions> -> <Function_Definitions>
	<Function_Definitions> -> <Function> <Function_Definitions>
	<Function> -> function <Identifier> ( <Opt_Parameter_List> ) <Opt_Declaration_List> <Body>
Token: id   Lexeme: convert1x
Token: separator   Lexeme: (
Token: id   Lexeme: fahr
	<Opt_Parameter_List> -> <Parameter_List>
	<Parameter_List> -> <Parameter> ;
	<Parameter> -> <IDs> <Qualifier>
	<IDs> -> <Identifier>
Token: keyword   Lexeme: int
	<Qualifier> -> int
Token: separator   Lexeme: )
Token: separator   Lexeme: {
	<Opt_Declaration_List> -> ϵ
	<Body> -> { <Statement_List> }
Token: keyword   Lexeme: return
	<Statement_List> -> <Statement>
	<Statement> -> <Return>
	<Return> -> return <Expression> ;
Token: int   Lexeme: 5
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Integer>
Token: operator   Lexeme: *
	<Term'> -> * <Factor> <Term'>
Token: separator   Lexeme: (
	<Factor> -> <Primary>
	<Primary> -> ( <Expression> )
Token: id   Lexeme: fahr
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: operator   Lexeme: -
	<Term'> -> ϵ
	<Expression'> -> - <Term> <Expression'>
Token: int   Lexeme: 32
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Integer>
Token: separator   Lexeme: )
	<Term'> -> ϵ
	<Expression'> -> ϵ
Token: operator   Lexeme: /
	<Term'> -> / <Factor> <Term'>
Token: int   Lexeme: 9
	<Factor> -> <Primary>
	<Primary> -> <Integer>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
Token: separator   Lexeme: }
Token: keyword   Lexeme: function
	<Function_Definitions> -> <Function>
	<Function> -> function <Identifier> ( <Opt_Parameter_List> ) <Opt_Declaration_List> <Body>
Token: id   Lexeme: made_up_function
Token: separator   Lexeme: (
Token: separator   Lexeme: )
	<Opt_Parameter_List> -> ϵ
Token: separator   Lexeme: {
	<Opt_Declaration_List> -> ϵ
	<Body> -> { <Statement_List> }
Token: keyword   Lexeme: if
	<Statement_List> -> <Statement>
	<Statement> -> <If>
	if ( <Condition> ) <Statement> otherwise <Statement> fi
Token: separator   Lexeme: (
Token: keyword   Lexeme: true
	<Condition> -> <Expression> <Relop> <Expression>
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> true
Token: operator   Lexeme: /=
	<Term'> -> ϵ
	<Relop> -> /=
Token: keyword   Lexeme: false
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> false
Token: separator   Lexeme: )
	<Term'> -> ϵ
Token: separator   Lexeme: {
	<Statement> -> <Compound>
	<Compound> -> { <Statement_List> }
Token: id   Lexeme: a
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Assign>
	<Assign> -> <Identifier> = <Expression> ;
Token: operator   Lexeme: =
Token: real   Lexeme: 3.2
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Real>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
Token: id   Lexeme: b
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Assign>
	<Assign> -> <Identifier> = <Expression> ;
Token: operator   Lexeme: =
Token: real   Lexeme: 1.0
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Real>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
Token: id   Lexeme: c
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Assign>
	<Assign> -> <Identifier> = <Expression> ;
Token: operator   Lexeme: =
Token: int   Lexeme: 42
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Integer>
Token: operator   Lexeme: +
	<Term'> -> ϵ
	<Expression'> -> + <Term> <Expression'>
Token: id   Lexeme: b
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
	<Expression'> -> ϵ
Token: keyword   Lexeme: return
	<Statement_List> -> <Statement>
	<Statement> -> <Return>
	<Return> -> return <Expression> ;
Token: id   Lexeme: a
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: operator   Lexeme: +
	<Term'> -> ϵ
	<Expression'> -> + <Term> <Expression'>
Token: id   Lexeme: b
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: operator   Lexeme: +
	<Term'> -> ϵ
	<Expression'> -> + <Term> <Expression'>
Token: id   Lexeme: c
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
	<Expression'> -> ϵ
Token: separator   Lexeme: }
Token: keyword   Lexeme: otherwise
Token: separator   Lexeme: {
	<Statement> -> <Compound>
	<Compound> -> { <Statement_List> }
Token: keyword   Lexeme: return
	<Statement_List> -> <Statement>
	<Statement> -> <Return>
	<Return> -> return <Expression> ;
Token: keyword   Lexeme: false
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> false
Token: separator   Lexeme: ;
	<Term'> -> ϵ
Token: separator   Lexeme: }
Token: separator   Lexeme: }
Token: separator   Lexeme: %%
Token: keyword   Lexeme: int
	<Opt_Declaration_List> -> <Declaration_List>
	<Declaration_List> -> <Declaration> ;
	<Declaration> -> int <IDs>
Token: id   Lexeme: low
	<IDs> -> <Identifier> , IDs
Token: separator   Lexeme: ,
Token: id   Lexeme: high
	<IDs> -> <Identifier> , IDs
Token: separator   Lexeme: ,
Token: id   Lexeme: step
	<IDs> -> <Identifier>
Token: separator   Lexeme: ;
Token: keyword   Lexeme: get
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Scan>
	<Scan> -> get ( <IDs> ) ;
Token: separator   Lexeme: (
Token: id   Lexeme: low
	<IDs> -> <Identifier> , IDs
Token: separator   Lexeme: ,
Token: id   Lexeme: high
	<IDs> -> <Identifier> , IDs
Token: separator   Lexeme: ,
Token: id   Lexeme: step
	<IDs> -> <Identifier>
Token: separator   Lexeme: )
Token: separator   Lexeme: ;
Token: keyword   Lexeme: while
	<Statement_List> -> <Statement>
	<Statement> -> <While>
	<While> -> while ( <Condition> ) <Statement>
Token: separator   Lexeme: (
Token: id   Lexeme: low
	<Condition> -> <Expression> <Relop> <Expression>
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: operator   Lexeme: <=
	<Term'> -> ϵ
	<Relop> -> <=
Token: id   Lexeme: high
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: separator   Lexeme: )
	<Term'> -> ϵ
Token: separator   Lexeme: {
	<Statement> -> <Compound>
	<Compound> -> { <Statement_List> }
Token: keyword   Lexeme: put
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Print>
	<Print> -> put ( <Expression> ) ;
Token: separator   Lexeme: (
Token: id   Lexeme: low
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: separator   Lexeme: )
	<Term'> -> ϵ
Token: separator   Lexeme: ;
Token: keyword   Lexeme: put
	<Statement_List> -> <Statement> <Statement_List>
	<Statement> -> <Print>
	<Print> -> put ( <Expression> ) ;
Token: separator   Lexeme: (
Token: id   Lexeme: convert1x
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier> ( <IDs> )
Token: separator   Lexeme: (
Token: id   Lexeme: low
	<IDs> -> <Identifier>
Token: separator   Lexeme: )
Token: separator   Lexeme: )
	<Term'> -> ϵ
Token: separator   Lexeme: ;
Token: id   Lexeme: low
	<Statement_List> -> <Statement>
	<Statement> -> <Assign>
	<Assign> -> <Identifier> = <Expression> ;
Token: operator   Lexeme: =
Token: id   Lexeme: low
	<Expression> -> <Term> <Expression'>
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: operator   Lexeme: +
	<Term'> -> ϵ
	<Expression'> -> + <Term> <Expression'>
Token: id   Lexeme: step
	<Term> -> <Factor> <Term'>
	<Factor> -> <Primary>
	<Primary> -> <Identifier>
Token: separator   Lexeme: ;
	<Term'> -> ϵ
	<Expression'> -> ϵ
Token: separator   Lexeme: }
Token: separator   Lexeme: %%
